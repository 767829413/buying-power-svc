// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package config

import (
	context "context"

	bouncer "gitlab.com/eAuction/bouncer"

	data "gitlab.com/eAuction/buying-power-svc/internal/data"
	copart "gitlab.com/eAuction/buying-power-svc/internal/services/api/ws/copart"

	exrates "gitlab.com/eAuction/exrates-svc/pkg/exrates"

	kafka "gitlab.com/eAuction/events/go/kafka"

	logan "gitlab.com/distributed_lab/logan/v3"

	mock "github.com/stretchr/testify/mock"

	net "net"

	participants "gitlab.com/eAuction/buying-power-svc/internal/services/api/ws/participants"

	payments "gitlab.com/eAuction/payment-service/pkg/payments"

	pgdb "gitlab.com/distributed_lab/kit/pgdb"

	platformer "gitlab.com/eAuction/platformer-svc/pkg/platformer"

	pq "github.com/lib/pq"

	sql "database/sql"
)

// MockConfig is an autogenerated mock type for the Config type
type MockConfig struct {
	mock.Mock
}

// AuctionsWriter provides a mock function with given fields:
func (_m *MockConfig) AuctionsWriter() kafka.AuctionEventWriter {
	ret := _m.Called()

	var r0 kafka.AuctionEventWriter
	if rf, ok := ret.Get(0).(func() kafka.AuctionEventWriter); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(kafka.AuctionEventWriter)
	}

	return r0
}

// AutoRechargeableIdentityTypes provides a mock function with given fields:
func (_m *MockConfig) AutoRechargeableIdentityTypes() []kafka.Identity_Type {
	ret := _m.Called()

	var r0 []kafka.Identity_Type
	if rf, ok := ret.Get(0).(func() []kafka.Identity_Type); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]kafka.Identity_Type)
		}
	}

	return r0
}

// Bouncer provides a mock function with given fields:
func (_m *MockConfig) Bouncer() bouncer.Bouncer {
	ret := _m.Called()

	var r0 bouncer.Bouncer
	if rf, ok := ret.Get(0).(func() bouncer.Bouncer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(bouncer.Bouncer)
		}
	}

	return r0
}

// BuyingPowerRecharger provides a mock function with given fields:
func (_m *MockConfig) BuyingPowerRecharger() BuyingPowerRecharger {
	ret := _m.Called()

	var r0 BuyingPowerRecharger
	if rf, ok := ret.Get(0).(func() BuyingPowerRecharger); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(BuyingPowerRecharger)
	}

	return r0
}

// DB provides a mock function with given fields:
func (_m *MockConfig) DB() *pgdb.DB {
	ret := _m.Called()

	var r0 *pgdb.DB
	if rf, ok := ret.Get(0).(func() *pgdb.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pgdb.DB)
		}
	}

	return r0
}

// DepositIDGenerator provides a mock function with given fields:
func (_m *MockConfig) DepositIDGenerator() data.DepositIDGenerator {
	ret := _m.Called()

	var r0 data.DepositIDGenerator
	if rf, ok := ret.Get(0).(func() data.DepositIDGenerator); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(data.DepositIDGenerator)
		}
	}

	return r0
}

// Deposits provides a mock function with given fields:
func (_m *MockConfig) Deposits() Deposits {
	ret := _m.Called()

	var r0 Deposits
	if rf, ok := ret.Get(0).(func() Deposits); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(Deposits)
	}

	return r0
}

// DepositsWriter provides a mock function with given fields:
func (_m *MockConfig) DepositsWriter() kafka.DepositEventWriter {
	ret := _m.Called()

	var r0 kafka.DepositEventWriter
	if rf, ok := ret.Get(0).(func() kafka.DepositEventWriter); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(kafka.DepositEventWriter)
	}

	return r0
}

// ExRatesConverter provides a mock function with given fields:
func (_m *MockConfig) ExRatesConverter() *exrates.Converter {
	ret := _m.Called()

	var r0 *exrates.Converter
	if rf, ok := ret.Get(0).(func() *exrates.Converter); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*exrates.Converter)
		}
	}

	return r0
}

// GetSupportedCountries provides a mock function with given fields:
func (_m *MockConfig) GetSupportedCountries() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// IdentitiesIngester provides a mock function with given fields:
func (_m *MockConfig) IdentitiesIngester() kafka.IngestConfig {
	ret := _m.Called()

	var r0 kafka.IngestConfig
	if rf, ok := ret.Get(0).(func() kafka.IngestConfig); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(kafka.IngestConfig)
	}

	return r0
}

// InjectRemoteStateGetter provides a mock function with given fields:
func (_m *MockConfig) InjectRemoteStateGetter() {
	_m.Called()
}

// IsAutoRechargeable provides a mock function with given fields: _a0
func (_m *MockConfig) IsAutoRechargeable(_a0 kafka.Identity_Type) bool {
	ret := _m.Called(_a0)

	var r0 bool
	if rf, ok := ret.Get(0).(func(kafka.Identity_Type) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// LeadsIngester provides a mock function with given fields:
func (_m *MockConfig) LeadsIngester() kafka.IngestConfig {
	ret := _m.Called()

	var r0 kafka.IngestConfig
	if rf, ok := ret.Get(0).(func() kafka.IngestConfig); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(kafka.IngestConfig)
	}

	return r0
}

// Listener provides a mock function with given fields:
func (_m *MockConfig) Listener() net.Listener {
	ret := _m.Called()

	var r0 net.Listener
	if rf, ok := ret.Get(0).(func() net.Listener); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(net.Listener)
		}
	}

	return r0
}

// Log provides a mock function with given fields:
func (_m *MockConfig) Log() *logan.Entry {
	ret := _m.Called()

	var r0 *logan.Entry
	if rf, ok := ret.Get(0).(func() *logan.Entry); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*logan.Entry)
		}
	}

	return r0
}

// LotsCacheByExternalIDPrefix provides a mock function with given fields:
func (_m *MockConfig) LotsCacheByExternalIDPrefix() data.LotsCache {
	ret := _m.Called()

	var r0 data.LotsCache
	if rf, ok := ret.Get(0).(func() data.LotsCache); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(data.LotsCache)
		}
	}

	return r0
}

// LotsIngester provides a mock function with given fields:
func (_m *MockConfig) LotsIngester() kafka.IngestConfig {
	ret := _m.Called()

	var r0 kafka.IngestConfig
	if rf, ok := ret.Get(0).(func() kafka.IngestConfig); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(kafka.IngestConfig)
	}

	return r0
}

// NewListener provides a mock function with given fields:
func (_m *MockConfig) NewListener() *pq.Listener {
	ret := _m.Called()

	var r0 *pq.Listener
	if rf, ok := ret.Get(0).(func() *pq.Listener); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pq.Listener)
		}
	}

	return r0
}

// ParticipantsRouter provides a mock function with given fields:
func (_m *MockConfig) ParticipantsRouter() participants.Router {
	ret := _m.Called()

	var r0 participants.Router
	if rf, ok := ret.Get(0).(func() participants.Router); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(participants.Router)
		}
	}

	return r0
}

// PaymentService provides a mock function with given fields:
func (_m *MockConfig) PaymentService() payments.PaymentService {
	ret := _m.Called()

	var r0 payments.PaymentService
	if rf, ok := ret.Get(0).(func() payments.PaymentService); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(payments.PaymentService)
		}
	}

	return r0
}

// Platformer provides a mock function with given fields:
func (_m *MockConfig) Platformer() platformer.Platformer {
	ret := _m.Called()

	var r0 platformer.Platformer
	if rf, ok := ret.Get(0).(func() platformer.Platformer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(platformer.Platformer)
		}
	}

	return r0
}

// RawDB provides a mock function with given fields:
func (_m *MockConfig) RawDB() *sql.DB {
	ret := _m.Called()

	var r0 *sql.DB
	if rf, ok := ret.Get(0).(func() *sql.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.DB)
		}
	}

	return r0
}

// Real provides a mock function with given fields: ctx, country
func (_m *MockConfig) Real(ctx context.Context, country string) (*copart.LiveBidder, error) {
	ret := _m.Called(ctx, country)

	var r0 *copart.LiveBidder
	if rf, ok := ret.Get(0).(func(context.Context, string) *copart.LiveBidder); ok {
		r0 = rf(ctx, country)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*copart.LiveBidder)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, country)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Simulation provides a mock function with given fields: ctx, country
func (_m *MockConfig) Simulation(ctx context.Context, country string) (*copart.LiveBidder, error) {
	ret := _m.Called(ctx, country)

	var r0 *copart.LiveBidder
	if rf, ok := ret.Get(0).(func(context.Context, string) *copart.LiveBidder); ok {
		r0 = rf(ctx, country)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*copart.LiveBidder)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, country)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage provides a mock function with given fields:
func (_m *MockConfig) Storage() data.Storage {
	ret := _m.Called()

	var r0 data.Storage
	if rf, ok := ret.Get(0).(func() data.Storage); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(data.Storage)
		}
	}

	return r0
}

// TBCTransactions provides a mock function with given fields:
func (_m *MockConfig) TBCTransactions() kafka.IngestConfig {
	ret := _m.Called()

	var r0 kafka.IngestConfig
	if rf, ok := ret.Get(0).(func() kafka.IngestConfig); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(kafka.IngestConfig)
	}

	return r0
}
